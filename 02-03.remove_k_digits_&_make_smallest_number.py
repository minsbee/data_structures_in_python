# 숫자 문자열 num과 정수 k가 주어진다
# k개의 숫자를 제거하여 가장 작은 수를 만들어라
# 결과는 문자열로 출력하시오

# 입력: num = "1432219", k = 3
# 출력: "1219"
# 
# 입력: num = "10200", k = 1
# 출력: "200"

num1 = "1432219"
k1 = 3
num2 = "10200"
k2 = 1
num3='123456'
k3 = 3

def solution1(num, k):
    stk = []
    counter = 0
    
    for i in range(len(num)):
        while stk and stk[-1] > num[i] and k != counter:
            stk.pop()
            counter += 1
        stk.append(num[i])
        
    if k - counter > 0:
        stk = stk[:len(stk) - ( k - counter)]
        
    answer = ''.join(stk).lstrip('0') or '0'
    print(f"answer: {answer}")
    return answer
        
solution1(num1, k1)
solution1(num2, k2)
solution1(num3, k3)


# 추가 해설: Remove K Digits (모노토닉 스택 응용)
#
# 핵심 아이디어: "가장 작은 수를 만들려면 앞자리부터 작은 숫자가 와야 한다"
# - 앞에 있는 큰 숫자를 먼저 제거해야 함
# - 스택을 사용해 "큰 숫자가 나타나면 이전의 더 큰 숫자들을 제거"
#
# 알고리즘 흐름:
# 1. 왼쪽부터 숫자를 순회하며:
#    - 현재 숫자가 스택 top보다 작으면 → 스택 top을 제거 (더 작은 숫자를 앞에 배치)
#    - k개를 모두 제거할 때까지 while로 반복
#    - 현재 숫자를 스택에 push
# 2. 순회 후에도 k개를 다 제거 못한 경우:
#    - 남은 개수만큼 뒤에서 제거 (오름차순 부분 처리)
# 3. leading zeros 제거 및 빈 문자열 처리
#
# 예시 1: num = "1432219", k = 3
# i=0 (1): stk=['1']
# i=1 (4): 4>1 → stk=['1','4']
# i=2 (3): 3<4 → 4 제거, counter=1, stk=['1','3']
# i=3 (2): 2<3 → 3 제거, counter=2, stk=['1','2']
# i=4 (2): 2=2 → stk=['1','2','2']
# i=5 (1): 1<2 → 2 제거, counter=3 (k 도달), stk=['1','2','1']
# i=6 (9): 9>1 → stk=['1','2','1','9']
# counter=3=k → 더 이상 제거 안함
# 결과: "1219"
#
# 예시 2: num = "10200", k = 1
# i=0 (1): stk=['1']
# i=1 (0): 0<1 → 1 제거, counter=1, stk=['0']
# i=2~4: stk=['0','2','0','0']
# lstrip('0') → "200"
#
# 예시 3 (오름차순): num = "123456", k = 3
# 순회 중 제거 안됨 (계속 오름차순) → stk=['1','2','3','4','5','6'], counter=0
# k-counter=3 → 뒤에서 3개 제거 → stk[:3] = ['1','2','3']
# 결과: "123"
#
# 엣지 케이스:
# 1. 오름차순 배열: while 조건 만족 안함 → 뒤에서 제거 필요
# 2. Leading zeros: "0200" → lstrip('0') → "200"
# 3. 모든 숫자 제거: "1111", k=4 → "" → "0" 반환
#
# 시간복잡도: O(n) - 각 숫자가 스택에 최대 1번 push, 1번 pop
# 공간복잡도: O(n) - 스택
#
# 프로그래머스 "큰 수 만들기"와 거의 동일한 유형
# (큰 수 만들기는 while 조건이 stk[-1] < num[i]로 반대)